# Проектная работа "Веб-ларек"

Проект реализован с помощью архитектурного паттерна MVP (Model-View-Presenter):

#### 1. Model
Слой данных и работы с ними. 
Функции:
- Хранение данных;
- Обработка данных;
- Уведомление Presenter об изменениях.

#### 2. View (Представление)
UI-слой, только отображает данные и передаёт действия пользователя Presenter.
Функции:
- отображение на основе данных (полученных от Presenter);
- передача пользовательских событий (клики, ввод текста) в Presenter.

#### 3. Presenter (Посредник)
Связующее звено между Model и View, содержит логику обработки событий.
Функции:
- запрос данных из Model, помещение новых данных в Model (например полученных через API);
- обработка действий пользователя (например, клик по кнопке);
- обновление View;
- API запросы.

Стек: HTML, SCSS, TS, Webpack

Структура проекта:
- src/ — исходные файлы проекта
- src/components/ — папка с JS компонентами
- src/components/base/ — папка с базовым кодом

Важные файлы:
- src/pages/index.html — HTML-файл главной страницы
- src/types/index.ts — файл с типами
- src/index.ts — точка входа приложения
- src/scss/styles.scss — корневой файл стилей
- src/utils/constants.ts — файл с константами
- src/utils/utils.ts — файл с утилитами

## Установка и запуск
Для установки и запуска проекта необходимо выполнить команды

```
npm install
npm run start
```

или

```
yarn
yarn start
```
## Сборка

```
npm run build
```

или

```
yarn build
```


## Архитектура

### Базовый код

#### 1. Класс EventEmitter

Реализует паттерн «Наблюдатель» и позволяет подписываться на события и уведомлять подписчиков
о наступлении события.

    *Методы*

Класс имеет методы **on** , **off** , **emit** — для подписки на событие, отписки от события и уведомления подписчиков о наступлении события соответственно.

Дополнительно реализованы методы **onAll** и **offAll** — для подписки на все события и сброса всех подписчиков.

Метод **trigger** , генерирующий заданное событие с заданными
аргументами. Это позволяет передавать его в качестве обработчика события в другие классы. Эти классы будут генерировать события, не будучи при этом напрямую зависимыми от класса EventEmitter.

### Модель данных

#### 1. Класс Items

Абстрактный класс-контейнер для работы с массивом элементов.

    *Типовой параметр*

**IItem** - определяет структуру элемента коллекции

    *Свойства*

**items** - массив элементов коллекции, элементы соответствуют интерфейсу IItem

    *Методы*

**getItem(id: string)** - возвращает элемент из массива по идентификатору

**getItems()** - возвращает весь массив элементов

**setItems(items: IItem[])** - полностью заменяет коллекцию элементов

#### 2. Класс BaseItems

Конкретная реализация базового массива элементов без дополнительной бизнес-логики.

    *Наследование*

Наследует класс Items<IItem>, при необходимости можно дополнить логику для базовых элементов

#### 3. Класс BasketItems

Специализированная реализация для контейнера элементов корзины покупок с дополнительной бизнес-логикой.

    *Наследование*

Расширяет Items<IItem>

    *Методы*

**toggleItem(item: IItem)** - переключает состояние элемента (добавляет/удаляет из массива)

**getTotalPrice()** - вычисляет и возвращает общую стоимость товаров в корзине

**getItemsId()** - возвращает массив идентификаторов товаров

**checkItem(id: string)** - проверяет наличие товара в корзине, возвращает boolean значение

**clear()** - полностью очищает корзину

    *Особенности*

1. Содержит специфичную для корзины бизнес-логику
2. Наследует все базовые методы работы с коллекцией
3. Автоматически генерирует события при изменениях (через Model)

#### 4. Класс OrderData

Реализует логику работы с данными заказа. Инкапсулирует состояние заказа и предоставляет методы для его изменения и валидации.

    *Типовой параметр*

**IOrder** - определяет структуру объекта с данными заказа

    *Свойства*

**order** - защищенное поле, хранящее объект данных заказа, объект соответсвует интерфейсу IOrder

    *Сеттеры*

**payment(payment: PaymentMethod)** - устанавливает способ оплаты, который соответсвует определенному типу PaymentMethod

**email(email: string)**, **phone(phone: string | number)**, **address(address: string)** - устанавливают данные покупателя

    *Методы*

**orderData** (getter) - возвращает текущий объкт order + возможна дополнительная логика проверок/вычислений в зависимости от реализации

**validateOrder()** - проверяет корректность заполнения полей заказа, возвращает boolean значение

**validateDeliveryData()** - проверяет корректность заполнения полей заказа с данными для доставки(первая форма), возвращает boolean значение

**clearOrder()** - сбрасывает состояние заказа к начальным значениям

### Представления (View)

#### 1. Абстрактный класс Component<T>

Базовый класс для всех UI-компонентов приложения. Инкапсулирует общую логику работы с DOM-элементами и предоставляет методы для манипуляции их состоянием.

    *Типовой параметр*

**T** - определяет структуру данных, используемых компонентом

    *Конструктор*

Принимает container (HTMLElement) - корневой DOM-элемент компонента

    *Методы*

**toggleClass** - переключает CSS-класс у элемента (Параметры: 
element - целевой DOM-элемент, 
className - имя класса, 
force (опционально) - явное указание состояния (true - добавить, false - удалить))

**setText** - устанавливает текстовое содержимое элемента (Параметры: 
element - целевой DOM-элемент, 
value - устанавливаемое значение)

**setDisabled** - управляет состоянием disabled элемента (Параметры:
element - целевой DOM-элемент,
state - флаг состояния (true - disabled, false - enabled))

**setHidden**, **setVisible** - управляют видимостью элемента

**setImage** - устанавливает атрибуты изображения
(Параметры:
element - элемент <img>,
src - путь к изображению,
alt (опционально) - альтернативный текст)

**render** - осуществляет отрисовку компонента на основе переданных данных (Параметры:
data (опционально) - данные для отображения (Partial<T>))

#### 2. Класс Page

Базовый класс страницы приложения, наследуемый от Component<IPage>. Управляет основными разделами страницы и их состоянием.

    *Наследование*

Расширяет Component<IPage>, получая базовую DOM-функциональность

    *Свойства*

**_counter** - элемент отображения счетчика (количество товаров в корзине)

**_gallery** - контейнер для отображения каталога товаров на странице

**_wrapper** - основной контейнер страницы

**_basket** - контейнер корзины покупок

    *Конструктор*

Принимает: 
container (HTMLElement) - корневой DOM-элемент компонента
events - экземпляр EventEmitter для работы с событиями

Определяет используемые элементы в контейнере и добавляет слушатель события открытия корзины

    *Методы*

**counter(value: number)** (setter) - обновляет значение счетчика товаров в корзине

**gallery(items: HTMLElement[])** (setter) - отображает переданные элементы (массив элементов) в разделе каталога

**locked(value: boolean)** (setter) - блокирует/разблокирует интерфейс страницы

#### 3. Класс Modal

Реализация модального окна, наследуемого от Component<IModalData>. Управляет отображением и содержимым модальных окон.

    *Свойства*

**_closeButton** - кнопка закрытия модального окна

**_content** - контейнер для содержимого

    *Конструктор*

Принимает: 
container (HTMLElement) - корневой элемент модального окна
events - экземпляр EventEmitter для работы с событиями

Определяет используемые элементы в контейнере и добавляет слушатели для закрытия модального окна

    *Методы*

**content(value: HTMLElement)** (setter) - устанавливает содержимое модального окна

**open()** - открывает модальное окно

**close()** - закрывает модальное окно

**render(data: IModalData)** - реализует отрисовку модального окна

#### 4. Класс Card

Наследуемый от Component<ICard<Category>> класс для отображения карточек товаров. Инкапсулирует логику работы с UI-элементами карточки и их данными.

    *Типовые параметры*

ICard<Category> - определяет структуру данных карточки с учетом категории товара

    *Свойства*

**_title** - элемент отображения названия товара

**_price** - элемент отображения цены

**_description** - элемент отображения описания

**_image** - элемент изображения товара

**_category** - элемент отображения категории

**_button** - кнопка действия (например, "В корзину")

**_index** - элемент отображения индекса карточки

    *Конструктор*

Принимает: 
blockName - класс корневого элемента для поиска элементов внутри контейнера через ensureElement()
container - корневой DOM-элемент карточки
actions (опционально) - объект с обработчиками действий

Определяет используемые элементы в контейнере и добавляет слушатель события для нажатия на кнопку при ее наличии

    *Сеттеры*

**id(value: string)** - устанавливает уникальный идентификатор карточки

**title(value: string)** - обновляет отображение названия товара

**price(value: number | null)** - обновляет отображение цены

**description(value: string | string[])** - устанавливает описание 

**image(value: string)** - обновляет изображение товара

**button(value: string)** - обновляет отображение текста кнопки

**category(value: Category)** - устанавливает категорию товара

**index(value: number)** - обновляет отображение индекса карточки с товаром

#### 5. Класс Form<T>

Наследуемый от Component<IFormState> класс для работы с HTML-формами. Обеспечивает валидацию и управление состоянием формы.

    *Типовые параметры*

IFormState - определяет валидность и ошибку полей формы

    *Свойства*

**_submit** - кнопка отправки формы

**_errors** - контейнер для отображения ошибок валидации

**container** - HTML-форма (расширяет базовый container)

**events** - экземпляр EventEmitter для работы с событиями

    *Конструктор*

Принимает: 
container - элемент <form>
events - экземпляр системы событий

Определяет используемые элементы в контейнере и добавляет слушатели событий изменения значений в инпутах и отправки формы

    *Mетоды*

**onInputChange** (защищенный) - обработчик изменения полей ввода (Параметры:
field - имя поля (ключ из типа T)
value - новое значение поля)

**valid** (setter) - управляет состоянием кнопки отправки (Параметры:
value - флаг валидности формы)

**errors** (setter) - реализует возможность отображения ошибок валидации (Параметры:
value - текст ошибки)

**render** - отрисовывает форму с переданными данными (Параметры:
state - объединение частичных данных формы и состояния)

#### 6. Класс OrderDeliveryForm

Специализированная реализация формы для ввода данных доставки заказа и выбора способа оплаты, наследуемая от Form<IOrder>.

    *Наследование*

Расширяет Form<IOrder>, добавляя специфичные поля

    *Свойства*

**_paymentCardButton** - кнопка выбора оплаты картой

**_paymentCashButton** - кнопка выбора оплаты наличными

**_addressInput** - поле для ввода адреса

    *Конструктор*

Принимает: 
container - элемент <form>
events - экземпляр системы событий

Определяет используемые элементы в контейнере и добавляет слушатели событий нажатия на кнопки выбора метода оплаты

    *Mетоды*

**payment** (setter) - устанавливает способ оплаты. Принимает аргумент типа PaymentMethod

**address** (setter) - устанавливает адрес доставки. Принимает строку, возможна реализация валидации или проверки на валидность

**address** (getter) - возвращает значение поля для ввода адреса

#### 7. Класс OrderContactForm

Специализированная реализация формы для ввода контактных данных, наследуемая от Form<IOrder>.

    *Наследование*

Расширяет Form<IOrder>, добавляя специфичные поля

    *Свойства*

**_emailInput** - поле для ввода электронной почты

**_phoneInput** - поле для ввода номера телефона

    *Конструктор*

Принимает: 
container - элемент <form>
events - экземпляр системы событий

Определяет используемые элементы в контейнере

    *Mетоды*

**email** (setter) - устанавливает email. Принимает строку, возможна реализация валидации или проверки на валидность

**email** (getter) - возвращает значение поля для ввода электронной почты

**phone** (setter) - устанавливает контактный номер телефона. Принимает строку, возможна реализация валидации или проверки на валидность

**phone** (getter) - возвращает значение поля для ввода номера телефона

**orderPending(value: boolean)** - блокирует/разблокирует инпуты для ввода данных и кнопку отправки формы, а также обновляет текст кнопки отправки формы

#### 8. Класс Success

Наследуемый от Component<ISuccess> UI компонент для отображения сообщения об успешном оформлении заказа с итоговой стоимостью.

    *Свойства*

**_close** - элемент кнопки закрытия/продолжения

**_total** - элемент отображение суммы заказа

    *Конструктор*

Принимает: 
container - корневой DOM-элемент компонента
actions - объект с обработчиками действий типа ISuccessActions

Определяет используемые элементы в контейнере и добавляет слушатели событий при их наличии на кнопку

    *Mетоды*

**total** (setter) - устанавливает текст с суммой заказа

#### 9. Класс Basket

Наследуемый от Component<IBasketView> компонент для отображения корзины покупок. Управляет отображением списка выбранных товаров, общей суммы и кнопки оформления заказа.

    *Свойства*

**_list** - контейнер для списка товаров

**_total** - элемент отображения общей суммы

**_button** - кнопка оформления заказа

    *Конструктор*

Принимает: 
container - корневой DOM-элемент корзины
events - экземпляр системы событий типа EventEmitter

Определяет используемые элементы в контейнере и добавляет слушатель события открытия формы заказа

    *Mетоды*

**items** (setter) - Обновляет список товаров в корзине и блокирует/разблокирует кнопку открытия формы заказа при наличии/отсутствии товаров в корзине. Принимает массив DOM-элементов карточек товаров

**total** (setter) - Обновляет отображение общей суммы. Принимает число или строку в зависимости от реализации + может преобразить тип в строку для отображения

### Presenter (index.ts)

Presenter — это центральный посредник между Model (данные) и View (отображение). В проекте он целиком находится в основном файле index.ts и для него не выделен отдельный класс. Он:
1. Слушает события от Model (например, изменение модели данных после получения их через API)
2. Обрабатывает действия пользователя из View (клики, ввод формы)
3. Обновляет Model и View в ответ на изменения
4. Является связующим звеном между Model и View и использует их методы. При этом Model и View напрямую не зависимы друг от друга

#### Примеры взаимодействий

1. Пример взаимодействия с Model

Получение данных с сервера и помещение их в модель. Сначала создали экземпляры классов, пусть это будут api и catalogItems. Далее при инициализации страницы получаем данные и помещаем их в модель:

```ts
api.get('/product/')
    .then(data => catalogItems.setItems(data))
    .catch(err => {
        console.error(err);
    });
```

2. Пример взаимодействия с View

Допустим класс Modal при реализации метода open() делает эмит открытия: emit('modal:open'). Мы можем слушать данное событие и блокировать прокрутку страницы с помощью метода класса Page если открыта модалка:

```ts
events.on('modal:open', () => {
    page.locked = true;
});
```

3. Пример взаимодействия  Model и View - при изменении каталога доступных товаров рендерим новый каталог на странице:

```ts
events.on('items:changed', () => {
    page.catalog = catalogItems.getItems().map(item => {
        const card = new Card(cloneTemplate( ... ));
        return card.render({ ... })
    })
});
```

#### Основные прослушиваемые события

1. Изменились элементы каталога ('items:changed'):
Рендерим каталог товаров на главной странице

2. Нажали на карточку в каталоге ('card:select'):
Рендерим модальное окно с детальной информацией о товаре

3. Нажали на кнопку добавления/удаления карточки ('card:toggle'):
Переключаем выбранную карточку в моделе корзины и перерендериваем представление корзины

4. Изменились элементы в корзине ('basket:changed'):
Меняем счетчик товаров в корзине на главной странице

5. Нажали на значок корзины ('basket:open'):
Рендерим модальное окно с корзиной

6. Нажали на кнопку оформления заказа в корзине ('order:open'):
Рендерим модальное окно с выбором способа оплаты и полем для ввода адреса

7. Нажали на кнопку выбора способа оплаты ('order.payment:change'):
Передаем в модель данных заказа выбранный способ

8. Переключили способ оплаты или изменили значение инпута в первой форме (/^order\..*:change/):
Очищаем ошибки валидации и разблокируем кнопку отправки первой формы

9. Нажали на кнопку отправки первой формы ('order:submit'):
Передаем в модель данных заказа значение инпута и проводим валидацию формы. При успешной валидации рендерим модальное окно второй формы заказа, при ошибки валидации блокируем кнопку отправки формы и отображаем сообщение с ошибкой

10. Изменили значение любого инпута во второй форме (/^contacts\..*:change/):
Очищаем ошибки валидации и разблокируем кнопку отправки второй формы

11. Нажали на кнопку отправки второй формы ('contacts:submit'):
Передаем в модель данных заказа значение инпутов второй формы и проводим валидацию формы. При успешной валидации отправляем API запрос с заказом на сервер и рендерим модальное окно об успешном заказе с суммой списанных средств. При ошибке валидации блокируем кнопку отправки формы и отображаем сообщение с ошибкой

12. Открыли модальное окно ('modal:open'):
Блокируем скролл страницы

13. Закрыли модальное окно ('modal:close'):
Разблокируем скролл страницы